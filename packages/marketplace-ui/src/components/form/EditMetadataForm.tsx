import {
  Alert,
  Button, Flex,
  Input, Text, VStack
} from "@chakra-ui/react";
import { useUmi } from '../../providers/useUmi'

import { yupResolver } from "@hookform/resolvers/yup";
import { createMetadataAccountV3, createMplTokenMetadataProgram, findMetadataPda, Metadata, updateMetadataAccountV2 } from "@metaplex-foundation/mpl-token-metadata";
import { AnchorWallet, useAnchorWallet, useWallet } from "@solana/wallet-adapter-react";
import { useWalletModal } from "@solana/wallet-adapter-react-ui";
import { web3JsRpc } from '@metaplex-foundation/umi-rpc-web3js';
/**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import { Option, OptionOrNullable } from '@metaplex-foundation/umi';
import {
  Serializer,
  array,
  option,
  string,
  struct,
  u16,
} from '@metaplex-foundation/umi/serializers';
import {
  Collection,
  CollectionArgs,
  Creator,
  CreatorArgs,
  Uses,
  UsesArgs,
  getCollectionSerializer,
  getCreatorSerializer,
  getUsesSerializer,
} from '@metaplex-foundation/mpl-token-metadata'

export type DataV2 = {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: Option<Array<Creator>>;
  collection: Option<Collection>;
  uses: Option<Uses>;
};

export type DataV2Args = {
  name: string;
  symbol: string;
  uri: string;
  sellerFeeBasisPoints: number;
  creators: OptionOrNullable<Array<CreatorArgs>>;
  collection: OptionOrNullable<CollectionArgs>;
  uses: OptionOrNullable<UsesArgs>;
};

export function getDataV2Serializer(): Serializer<DataV2Args, DataV2> {
  return struct<DataV2>(
    [
      ['name', string()],
      ['symbol', string()],
      ['uri', string()],
      ['sellerFeeBasisPoints', u16()],
      ['creators', option(array(getCreatorSerializer()))],
      ['collection', option(getCollectionSerializer())],
      ['uses', option(getUsesSerializer())],
    ],
    { description: 'DataV2' }
  ) as Serializer<DataV2Args, DataV2>;
}
import { PublicKey, Signer, TransactionInstruction } from "@solana/web3.js";
import {
  useMint,
  useProvider,
  usePublicKey,
  useStrataSdks,
  useTokenMetadata
} from "@strata-foundation/react";
import { useRouter } from "next/router";
import React, { useEffect } from "react";
import { useAsyncCallback } from "react-async-hook";
import { DefaultValues, FormProvider, useForm } from "react-hook-form";
import * as yup from "yup";
import { FormControlWithError } from "./FormControlWithError";
import { MintSelect } from "./MintSelect";
import { IMetadataFormProps, TokenMetadataInputs } from "./TokenMetadataInputs";
import { publicKey, signerIdentity, Umi } from "@metaplex-foundation/umi"; // Added anchorSignerIdentity import
import { Data } from "@metaplex-foundation/mpl-core/dist/src/utils/borsh";
import { SplTokenMetadata } from "@strata-foundation/spl-utils";
import { Wallet } from "anchor-17";
import { walletAdapterIdentity } from '@metaplex-foundation/umi-signer-wallet-adapters';
import { mplTokenMetadata } from "@metaplex-foundation/mpl-token-metadata";
import { irysUploader } from '@metaplex-foundation/umi-uploader-irys';
import { mplToolbox } from "@metaplex-foundation/mpl-toolbox";
 

  interface IEditMetadataFormProps extends IMetadataFormProps {
    symbol: string;
    mint: string;
    externalUrl: string;
  }

  const validationSchema = yup.object({
    mint: yup.string().required(),
    image: yup.mixed(),
    name: yup.string().required().min(2),
    description: yup.string(),
    symbol: yup.string().min(2).max(10),
    externalUrl: yup.string(),
  });


  async function editMetadata(
    values: IEditMetadataFormProps,
    wallet: Wallet,
    umi: Umi
  ): Promise<PublicKey> {
    const mintKey = values.mint ? new PublicKey(values.mint) : null;
    if (!mintKey) {
      throw new Error("Mint key is not set");
    }
    
   umi
      .use(walletAdapterIdentity(wallet))
      .use(mplTokenMetadata())
      .use(irysUploader())
      .use(mplToolbox());
  
    const uri = await umi.uploader.uploadJson({
      name: values.name,
      symbol: values.symbol,
      description: values.description,
      image: values.image,
      external_url: values.externalUrl,
      attributes: [],
    });
    const metadata = await findMetadataPda(umi, { mint: publicKey(mintKey) });
    const data = {
      // Max name len 32
      name: values.name.substring(0, 32),
      symbol: values.symbol.substring(0, 10),
      uri,
      sellerFeeBasisPoints: 0,
      creators: null,
      collection: null,
      uses: null,
    };
    
    const tx = await createMetadataAccountV3(umi, {
      metadata,
      data,
      mint: publicKey(mintKey),
      mintAuthority: umi.payer,
      updateAuthority: umi.payer,
      isMutable: true,
      collectionDetails:null
    }).buildAndSign(umi);
    await umi.rpc.sendTransaction(tx);
    return mintKey;
  }
  
  export const EditMetadataForm = ({
    values,
    onComplete,
  }: {
    values: DefaultValues<IEditMetadataFormProps>;
    onComplete?: (mintKey: PublicKey) => void;
  }) => {
    const formProps = useForm<IEditMetadataFormProps>({
      resolver: yupResolver(validationSchema),
      defaultValues: values,
    });
    const wallet = useWallet();
    const { execute, loading, error } = useAsyncCallback(editMetadata);
  
  const {
    register,
    handleSubmit,
    watch,
    setValue,
    formState: { errors, isSubmitting },
  } = formProps;
  const { awaitingApproval, provider } = useProvider();
  const { visible, setVisible } = useWalletModal();
  const { connected, publicKey } = useWallet();
  const router = useRouter();
  const { mintKey: mintKeyRaw } = router.query;
  const { mint, name, symbol } = watch();
  const mintKey = usePublicKey(mint as string | undefined);
  const mintAcc = useMint(mintKey);
  const { metadata, data, image } = useTokenMetadata(mintKey);
  const insufficientAuthority = metadata?.updateAuthority
    ? metadata.updateAuthority != publicKey?.toBase58()
    : false;
  useEffect(() => {
    if (mint) {
      setValue("mint", mint as string);
    }
  }, [mint, router, setValue]);
  useEffect(() => {
    if (mintKeyRaw) {
      const mintKey = new PublicKey(mintKeyRaw);
      setValue("mint", mintKey.toString());
    }
  }, [setValue, mintKeyRaw])
  useEffect(() => {
    if (metadata && data && image && !(isSubmitting || loading)) {
      setValue("name", metadata?.data.name);
      setValue("symbol", metadata?.data.symbol);
      setValue("description", data?.description || "");
      setValue("externalUrl", data?.external_url || "");

      (async () => {
        const imageFile = await getFileFromUrl(image, "image");
        if (imageFile) setValue("image", imageFile);
      })();
    }
  }, [setValue, metadata, data, image]);
const umi = useUmi()
  const onSubmit = async (values: IEditMetadataFormProps) => {
    if (!wallet) {
      console.error("Wallet not connected");
      return;
    }
    await execute(values, wallet, umi);
    onComplete && onComplete(new PublicKey(values.mint));
  };

  return (
    <Flex position="relative" w="100%">
      {!connected && (
        <Flex
          position="absolute"
          w="full"
          h="full"
          zIndex="1"
          flexDirection="column"
        >
          <Flex justifyContent="center">
            <Button
              colorScheme="orange"
              variant="outline"
              onClick={() => setVisible(!visible)}
            >
              Connect Wallet
            </Button>
          </Flex>
          <Flex w="full" h="full" bg="white" opacity="0.6" />
        </Flex>
      )}
      <FormProvider {...formProps}>
        <form onSubmit={handleSubmit(onSubmit)} style={{ width: "100%" }}>
          <VStack spacing={8} w="full">
            <FormControlWithError
              id="mint"
              help="The mint/token id of the token whose metadata you wish to update."
              label="Mint"
              errors={errors}
            >
              {name && (
                <Text color="gray.400" size="sm">
                  {name} ({symbol})
                </Text>
              )}
              <MintSelect
                value={watch("mint") || ""}
                onChange={(s) => setValue("mint", s)}
              />
            </FormControlWithError>
            <TokenMetadataInputs entityName="Token" />
            <FormControlWithError
              id="symbol"
              help="A less than 10 character symbol for this token."
              label="Short Name"
              errors={errors}
            >
              <Input {...register("symbol")} />
            </FormControlWithError>
            { mintAcc && mintAcc.decimals == 0 && (
              <FormControlWithError
                id="externalUrl"
                help="An optional URL that will be rendered in some wallets and explorers"
                label="External URL"
                errors={errors}
              >
                <Input {...register("externalUrl")} />
              </FormControlWithError>
            )}
            {error && <Alert status="error">{error.toString()}</Alert>}

            <Button
              isDisabled={insufficientAuthority}
              type="submit"
              alignSelf="flex-end"
              colorScheme="primary"
              isLoading={isSubmitting || loading}
              loadingText={awaitingApproval ? "Awaiting Approval" : "Loading"}
            >
              { insufficientAuthority ? "You do not hold the update authority" : metadata ? "Update Metadata" : "Create Metadata" }
            </Button>
          </VStack>
        </form>
      </FormProvider>
    </Flex>
  );
};

const getFileFromUrl = async (
  url: string | undefined,
  name: string,
  defaultType: string = "image/jpeg"
): Promise<File | undefined> => {
  if (!url) {
    return undefined;
  }

  const data = await fetch(url, { cache: "no-cache" });
  const blob = await data.blob();
  if (!blob.type.includes("image")) return undefined
  const fileName = `${name}${blob.type === defaultType ? ".jpeg" : ".png"}`;
  const file = new File([blob], fileName, { type: blob.type || defaultType });

  return file;
};